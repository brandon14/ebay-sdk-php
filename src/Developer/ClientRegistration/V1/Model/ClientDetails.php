<?php

/**
 * This file is part of the brandon14/ebay-sdk-php package.
 *
 * MIT License
 *
 * Copyright (c) 2022 Brandon Clothier
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

declare(strict_types=1);

/**
 * ClientDetails.
 *
 * PHP version ^7.2 || ^8.0
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */

/**
 * Developer Registration API.
 *
 * <span class=\"tablenote\"><b>Note:</b> The Client Registration API is not intended for use by developers who have previously registered for a Developer Account on the eBay platform.</span><br/>The Client Registration API provides Dynamic Client Registration for regulated Third Party Providers (TPPs) who are, or will be, engaged in financial transactions on behalf of individuals domiciled in the EU/UK. This is required by the EU's Second Payment Services Directive (PSD2) which requires all regulated Account Servicing Payment Service Providers (ASPSPs) to provide secure APIs to access account and payment services on behalf of account holders.<br/><br/>A successful registration response returns a <b>HTTP 201 Created</b> status code with a JSON payload [RFC7519] that includes registration information.
 *
 * The version of the OpenAPI document: v1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace TNT\Ebay\Developer\ClientRegistration\V1\Model;

use ArrayAccess;
use TNT\Ebay\Developer\ClientRegistration\V1\ObjectSerializer;

/**
 * ClientDetails Class Doc Comment.
 *
 * @category Class
 * @description This container stores information about the third party provider&#39;s financial application that has been registered with eBay.
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null
 */
class ClientDetails implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
     * The original name of the model.
     *
     * @var string
     */
    protected static $openAPIModelName = 'ClientDetails';

    /**
     * Array of property to type mappings. Used for (de)serialization.
     *
     * @var string[]
     */
    protected static $openAPITypes = [
        'client_id' => 'string',
        'client_id_issued_at' => 'int',
        'client_name' => 'string',
        'client_secret' => 'string',
        'client_secret_expires_at' => 'int',
        'contacts' => 'string[]',
        'grant_types' => 'string[]',
        'policy_uri' => 'string',
        'redirect_uris' => 'string[]',
        'scope' => 'string',
        'software_id' => 'string',
        'software_statement' => 'string',
    ];

    /**
     * Array of property to format mappings. Used for (de)serialization.
     *
     * @var string[]
     * @phpstan-var array<string, string|null>
     * @psalm-var array<string, string|null>
     */
    protected static $openAPIFormats = [
        'client_id' => null,
        'client_id_issued_at' => 'int32',
        'client_name' => null,
        'client_secret' => null,
        'client_secret_expires_at' => 'int32',
        'contacts' => null,
        'grant_types' => null,
        'policy_uri' => null,
        'redirect_uris' => null,
        'scope' => null,
        'software_id' => null,
        'software_statement' => null,
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization.
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization.
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name.
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'client_id' => 'client_id',
        'client_id_issued_at' => 'client_id_issued_at',
        'client_name' => 'client_name',
        'client_secret' => 'client_secret',
        'client_secret_expires_at' => 'client_secret_expires_at',
        'contacts' => 'contacts',
        'grant_types' => 'grant_types',
        'policy_uri' => 'policy_uri',
        'redirect_uris' => 'redirect_uris',
        'scope' => 'scope',
        'software_id' => 'software_id',
        'software_statement' => 'software_statement',
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses).
     *
     * @var string[]
     */
    protected static $setters = [
        'client_id' => 'setClientId',
        'client_id_issued_at' => 'setClientIdIssuedAt',
        'client_name' => 'setClientName',
        'client_secret' => 'setClientSecret',
        'client_secret_expires_at' => 'setClientSecretExpiresAt',
        'contacts' => 'setContacts',
        'grant_types' => 'setGrantTypes',
        'policy_uri' => 'setPolicyUri',
        'redirect_uris' => 'setRedirectUris',
        'scope' => 'setScope',
        'software_id' => 'setSoftwareId',
        'software_statement' => 'setSoftwareStatement',
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests).
     *
     * @var string[]
     */
    protected static $getters = [
        'client_id' => 'getClientId',
        'client_id_issued_at' => 'getClientIdIssuedAt',
        'client_name' => 'getClientName',
        'client_secret' => 'getClientSecret',
        'client_secret_expires_at' => 'getClientSecretExpiresAt',
        'contacts' => 'getContacts',
        'grant_types' => 'getGrantTypes',
        'policy_uri' => 'getPolicyUri',
        'redirect_uris' => 'getRedirectUris',
        'scope' => 'getScope',
        'software_id' => 'getSoftwareId',
        'software_statement' => 'getSoftwareStatement',
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name.
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses).
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests).
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    /**
     * Associative array for storing property values.
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor.
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['client_id'] = $data['client_id'] ?? null;
        $this->container['client_id_issued_at'] = $data['client_id_issued_at'] ?? null;
        $this->container['client_name'] = $data['client_name'] ?? null;
        $this->container['client_secret'] = $data['client_secret'] ?? null;
        $this->container['client_secret_expires_at'] = $data['client_secret_expires_at'] ?? null;
        $this->container['contacts'] = $data['contacts'] ?? null;
        $this->container['grant_types'] = $data['grant_types'] ?? null;
        $this->container['policy_uri'] = $data['policy_uri'] ?? null;
        $this->container['redirect_uris'] = $data['redirect_uris'] ?? null;
        $this->container['scope'] = $data['scope'] ?? null;
        $this->container['software_id'] = $data['software_id'] ?? null;
        $this->container['software_statement'] = $data['software_statement'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed.
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }

    /**
     * Gets client_id.
     *
     * @return string|null
     */
    public function getClientId()
    {
        return $this->container['client_id'];
    }

    /**
     * Sets client_id.
     *
     * @param string|null $client_id a unique, eBay-generated id assigned to the third party application at the time it was registered
     *
     * @return self
     */
    public function setClientId($client_id)
    {
        $this->container['client_id'] = $client_id;

        return $this;
    }

    /**
     * Gets client_id_issued_at.
     *
     * @return int|null
     */
    public function getClientIdIssuedAt()
    {
        return $this->container['client_id_issued_at'];
    }

    /**
     * Sets client_id_issued_at.
     *
     * @param int|null $client_id_issued_at The UNIX timestamp when the <code>client_id</code> was issued. This time is represented as the number of seconds from \"1970-01-01T00:00:00Z\", as measured in UTC, until the date/time of issuance. Refer to <a href=\"https://datatracker.ietf.org/doc/html/rfc7591#section-2.3 \" target= \"_blank \">RFC 7591 - OAuth 2.0 Dynamic Client Registration Protocol</a> for complete information.
     *
     * @return self
     */
    public function setClientIdIssuedAt($client_id_issued_at)
    {
        $this->container['client_id_issued_at'] = $client_id_issued_at;

        return $this;
    }

    /**
     * Gets client_name.
     *
     * @return string|null
     */
    public function getClientName()
    {
        return $this->container['client_name'];
    }

    /**
     * Sets client_name.
     *
     * @param string|null $client_name User-friendly name for the third party financial application.<br/><br/><span class=\"tablenote\"><b>Note:</b> Language tags are not supported. Therefore, <code>client_name</code> will be specified in English.</span>
     *
     * @return self
     */
    public function setClientName($client_name)
    {
        $this->container['client_name'] = $client_name;

        return $this;
    }

    /**
     * Gets client_secret.
     *
     * @return string|null
     */
    public function getClientSecret()
    {
        return $this->container['client_secret'];
    }

    /**
     * Sets client_secret.
     *
     * @param string|null $client_secret A unique OAuth 2.0 secret string assigned by eBay to the third party application at the time it is registered. This value should be unique for multiple instances of a client using the same <code>client_id</code>. This value is used by confidential clients to authenticate to the token endpoint, as described in OAuth 2.0 [RFC6749], Section 2.3.1.<br/><br/><span class=\"tablenote\"><b>Note:</b> <code>client_secret</code> is unique to the organization identifier of subject name which contains jurisdiction, NCA Id, and Authorization Number.</span>
     *
     * @return self
     */
    public function setClientSecret($client_secret)
    {
        $this->container['client_secret'] = $client_secret;

        return $this;
    }

    /**
     * Gets client_secret_expires_at.
     *
     * @return int|null
     */
    public function getClientSecretExpiresAt()
    {
        return $this->container['client_secret_expires_at'];
    }

    /**
     * Sets client_secret_expires_at.
     *
     * @param int|null $client_secret_expires_at The UNIX timestamp when the <code>client_secret</code> expires.<br/><br/><span class=\"tablenote\"><b>Note:</b> When a <code>client_secret</code> has been provided, this field is <b>REQUIRED</b>.</span><br/>A returned value of <b>0</b> indicates that the <code>client_secret</code> never expires.<br/><br/>This time is represented as the number of seconds from \"1970-01-01T00:00:00Z\", as measured in UTC, until the expiration date and time. Refer to <a href=\"https://datatracker.ietf.org/doc/html/rfc7591#section-3.2.1 \" target= \"_blank \">RFC 7591 - OAuth 2.0 Dynamic Client Registration Protocol section 3.2.1</a> for complete information.
     *
     * @return self
     */
    public function setClientSecretExpiresAt($client_secret_expires_at)
    {
        $this->container['client_secret_expires_at'] = $client_secret_expires_at;

        return $this;
    }

    /**
     * Gets contacts.
     *
     * @return string[]|null
     */
    public function getContacts()
    {
        return $this->container['contacts'];
    }

    /**
     * Sets contacts.
     *
     * @param string[]|null $contacts this container stores an array of email addresses for representatives at the third party provider responsible for the application being registered
     *
     * @return self
     */
    public function setContacts($contacts)
    {
        $this->container['contacts'] = $contacts;

        return $this;
    }

    /**
     * Gets grant_types.
     *
     * @return string[]|null
     */
    public function getGrantTypes()
    {
        return $this->container['grant_types'];
    }

    /**
     * Sets grant_types.
     *
     * @param string[]|null $grant_types An array of OAuth 2.0 grant type strings that the client software can use at the token endpoint. Supported grant type values are:<br/><ul><li><code>authorization_code</code>: The authorization code grant type defined in OAuth 2.0, Section 4.1.</li><li><code>client_credentials</code>: The client credentials grant type defined in OAuth 2.0, Section 4.4.</li></ul>If the token endpoint is used in the grant type, the value of this parameter <b>MUST</b> be the same as the value of the <code>grant_type</code> parameter passed to the token endpoint defined in the grant type definition. Authorization servers <b>may</b> allow for other values as defined in the grant type extension process described in OAuth 2.0, Section 4.5. If omitted, the default behavior is that the client will use only the <code>authorization_code</code> Grant Type.
     *
     * @return self
     */
    public function setGrantTypes($grant_types)
    {
        $this->container['grant_types'] = $grant_types;

        return $this;
    }

    /**
     * Gets policy_uri.
     *
     * @return string|null
     */
    public function getPolicyUri()
    {
        return $this->container['policy_uri'];
    }

    /**
     * Sets policy_uri.
     *
     * @param string|null $policy_uri The URL string pointing to a human-readable privacy policy document that describes how the third party provider collects, uses, retains, and discloses personal data.<br/><br/><span class=\"tablenote\"><b>Note:</b> Only HTTPS URLs are supported for <code>policy_uri</code> strings.</span><br/><span class=\"tablenote\"><b>Note:</b> This URL <b>must not</b> point to the eBay Privacy Policy.</span><br/>The authorization server should display this secure URL to the end-user if it is provided. The value of this field <b>must</b> point to a valid and secure web page.<br/><br/><span class=\"tablenote\"><b>Note:</b> Language tags are not supported. Therefore, <code>policy_uri</code> will be displayed in English.</span>
     *
     * @return self
     */
    public function setPolicyUri($policy_uri)
    {
        $this->container['policy_uri'] = $policy_uri;

        return $this;
    }

    /**
     * Gets redirect_uris.
     *
     * @return string[]|null
     */
    public function getRedirectUris()
    {
        return $this->container['redirect_uris'];
    }

    /**
     * Sets redirect_uris.
     *
     * @param string[]|null $redirect_uris An eBay system-generated value assigned to the application. This value represents the redirect uri(s) submitted by the user either in the request payload (i.e., the <code>redirect_uris</code> field,) or the <code>software_statement</code>.
     *
     * @return self
     */
    public function setRedirectUris($redirect_uris)
    {
        $this->container['redirect_uris'] = $redirect_uris;

        return $this;
    }

    /**
     * Gets scope.
     *
     * @return string|null
     */
    public function getScope()
    {
        return $this->container['scope'];
    }

    /**
     * Sets scope.
     *
     * @param string|null $scope String containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens. The semantics of values in this list are service specific.
     *
     * @return self
     */
    public function setScope($scope)
    {
        $this->container['scope'] = $scope;

        return $this;
    }

    /**
     * Gets software_id.
     *
     * @return string|null
     */
    public function getSoftwareId()
    {
        return $this->container['software_id'];
    }

    /**
     * Sets software_id.
     *
     * @param string|null $software_id A unique identifier string provided by the client developer or software publisher at the time of registration that identifies the client software being registered.<br/><br/>Unlike <code>client_id</code> which should change between instances, the <CODE>software_id</code> should be the same value for all instances of the client software. That is, the <code>software_id</code> should remain unchanged across multiple updates or versions of the same piece of software.
     *
     * @return self
     */
    public function setSoftwareId($software_id)
    {
        $this->container['software_id'] = $software_id;

        return $this;
    }

    /**
     * Gets software_statement.
     *
     * @return string|null
     */
    public function getSoftwareStatement()
    {
        return $this->container['software_statement'];
    }

    /**
     * Sets software_statement.
     *
     * @param string|null $software_statement The Software Statement Assertion (SSA), a JSON Web Token (JWT), that has been issued by the OpenBanking identifier. Refer to <a href=\"https://datatracker.ietf.org/doc/html/rfc7591#section-2.3 \" target= \"_blank \">RFC 7591 - OAuth 2.0 Dynamic Client Registration Protocol</a> for complete information.
     *
     * @return self
     */
    public function setSoftwareStatement($software_statement)
    {
        $this->container['software_statement'] = $software_statement;

        return $this;
    }

    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param int $offset Offset
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param int $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     */
    public function offsetSet($offset, $value): void
    {
        if (null === $offset) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param int $offset Offset
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     *
     * @see https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed returns data which can be serialized by json_encode(), which is a value
     *               of any type other than a resource
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
        return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object.
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object.
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
