<?php

/**
 * This file is part of the brandon14/ebay-sdk-php package.
 *
 * MIT License
 *
 * Copyright (c) 2022 Brandon Clothier
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

declare(strict_types=1);

/**
 * FeedTypeApi.
 *
 * PHP version ^7.2 || ^8.0
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */

/**
 * Buy Feed API.
 *
 * The Feed API provides the ability to download TSV_GZIP feed files containing eBay items and an hourly snapshot file for a specific category, date, and marketplace.<br /><br />In addition to the API, there is an open-source Feed SDK written in Java that downloads, combines files into a single file when needed, and unzips the entire feed file. It also lets you specify field filters to curate the items in the file.
 *
 * The version of the OpenAPI document: v1.0.1
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace TNT\Ebay\Buy\Feed\V1\Api;

use GuzzleHttp\Client;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Psr7\MultipartStream;
use TNT\Ebay\Buy\Feed\V1\ApiException;
use TNT\Ebay\Buy\Feed\V1\Configuration;
use TNT\Ebay\Buy\Feed\V1\HeaderSelector;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use TNT\Ebay\Buy\Feed\V1\ObjectSerializer;

/**
 * FeedTypeApi Class Doc Comment.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */
class FeedTypeApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index.
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index.
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfiguration()
    {
        return $this->config;
    }

    /**
     * Operation getFeedType.
     *
     * @param string $feed_type_id The unique identifier for the feed type to be used as a search filter.&lt;br /&gt;&lt;br /&gt;Use the &lt;b&gt;getFeedTypes&lt;/b&gt; method to identify the available feed types.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;span style&#x3D;\&quot;color:#004680\&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/span&gt; Refer to &lt;a href&#x3D;\&quot;/api-docs/buy/feed/v1/static/overview.html#feed-types\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Supported feed types&lt;/a&gt; to learn more about the feed types supported by the Feed API.&lt;/span&gt; (required)
     *
     * @throws \TNT\Ebay\Buy\Feed\V1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \TNT\Ebay\Buy\Feed\V1\Model\FeedType
     */
    public function getFeedType($feed_type_id)
    {
        [$response] = $this->getFeedTypeWithHttpInfo($feed_type_id);

        return $response;
    }

    /**
     * Operation getFeedTypeWithHttpInfo.
     *
     * @param string $feed_type_id The unique identifier for the feed type to be used as a search filter.&lt;br /&gt;&lt;br /&gt;Use the &lt;b&gt;getFeedTypes&lt;/b&gt; method to identify the available feed types.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;span style&#x3D;\&quot;color:#004680\&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/span&gt; Refer to &lt;a href&#x3D;\&quot;/api-docs/buy/feed/v1/static/overview.html#feed-types\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Supported feed types&lt;/a&gt; to learn more about the feed types supported by the Feed API.&lt;/span&gt; (required)
     *
     * @throws \TNT\Ebay\Buy\Feed\V1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \TNT\Ebay\Buy\Feed\V1\Model\FeedType, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeedTypeWithHttpInfo($feed_type_id)
    {
        $request = $this->getFeedTypeRequest($feed_type_id);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }

            switch ($statusCode) {
                case 200:
                    if ('\TNT\Ebay\Buy\Feed\V1\Model\FeedType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TNT\Ebay\Buy\Feed\V1\Model\FeedType', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\TNT\Ebay\Buy\Feed\V1\Model\FeedType';

            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TNT\Ebay\Buy\Feed\V1\Model\FeedType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeedTypeAsync.
     *
     * @param string $feed_type_id The unique identifier for the feed type to be used as a search filter.&lt;br /&gt;&lt;br /&gt;Use the &lt;b&gt;getFeedTypes&lt;/b&gt; method to identify the available feed types.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;span style&#x3D;\&quot;color:#004680\&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/span&gt; Refer to &lt;a href&#x3D;\&quot;/api-docs/buy/feed/v1/static/overview.html#feed-types\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Supported feed types&lt;/a&gt; to learn more about the feed types supported by the Feed API.&lt;/span&gt; (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeedTypeAsync($feed_type_id)
    {
        return $this->getFeedTypeAsyncWithHttpInfo($feed_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeedTypeAsyncWithHttpInfo.
     *
     * @param string $feed_type_id The unique identifier for the feed type to be used as a search filter.&lt;br /&gt;&lt;br /&gt;Use the &lt;b&gt;getFeedTypes&lt;/b&gt; method to identify the available feed types.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;span style&#x3D;\&quot;color:#004680\&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/span&gt; Refer to &lt;a href&#x3D;\&quot;/api-docs/buy/feed/v1/static/overview.html#feed-types\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Supported feed types&lt;/a&gt; to learn more about the feed types supported by the Feed API.&lt;/span&gt; (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeedTypeAsyncWithHttpInfo($feed_type_id)
    {
        $returnType = '\TNT\Ebay\Buy\Feed\V1\Model\FeedType';
        $request = $this->getFeedTypeRequest($feed_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'getFeedType'.
     *
     * @param string $feed_type_id The unique identifier for the feed type to be used as a search filter.&lt;br /&gt;&lt;br /&gt;Use the &lt;b&gt;getFeedTypes&lt;/b&gt; method to identify the available feed types.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;span style&#x3D;\&quot;color:#004680\&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/span&gt; Refer to &lt;a href&#x3D;\&quot;/api-docs/buy/feed/v1/static/overview.html#feed-types\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Supported feed types&lt;/a&gt; to learn more about the feed types supported by the Feed API.&lt;/span&gt; (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFeedTypeRequest($feed_type_id)
    {
        // verify the required parameter 'feed_type_id' is set
        if ($feed_type_id === null || (is_array($feed_type_id) && count($feed_type_id) === 0)) {
            throw new \InvalidArgumentException('Missing the required parameter $feed_type_id when calling getFeedType');
        }

        $resourcePath = '/feed_type/{feed_type_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($feed_type_id !== null) {
            $resourcePath = str_replace(
                '{'.'feed_type_id'.'}',
                ObjectSerializer::toPathValue($feed_type_id),
                $resourcePath
            );
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // For HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // For HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($queryParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (! empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeedTypes.
     *
     * @param string $continuation_token The server returns this token to the web client when the responses received require multiple pages to display. The web client sends this token back to the server to get the next page of results. (optional)
     * @param string $feed_scope         Specifies the frequency with which the feed file is made available (&lt;code&gt;HOURLY&lt;/code&gt;, &lt;code&gt;DAILY&lt;/code&gt;, &lt;code&gt;WEEKLY&lt;/code&gt;).&lt;br /&gt;&lt;br /&gt;Currently only &lt;code&gt;DAILY&lt;/code&gt; is supported. (optional)
     * @param string $limit              The number of records to show in the current response.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Default:&lt;/b&gt; 20&lt;br /&gt;&lt;b&gt;Minimum:&lt;/b&gt; 20&lt;br /&gt;&lt;b&gt;Maximum:&lt;/b&gt; 100 (optional)
     * @param string $marketplace_ids    Use this parameter to limit marketplaces you want to see. To search for multiple marketplaces at once, list them in the URI separated by commas.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;GET https://api.ebay.com/buy/feed/v1/feedtype?marketplaceids&#x3D;EBAY_FR,EBAY_AU&lt;/code&gt;.&lt;br /&gt;&lt;br /&gt;See &lt;a href&#x3D;\&quot;/api-docs/buy/feed/v1/overview.html#API\&quot;&gt;API Restrictions&lt;/a&gt; for information on supported sites. (optional)
     *
     * @throws \TNT\Ebay\Buy\Feed\V1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \TNT\Ebay\Buy\Feed\V1\Model\FeedTypeSearchResponse
     */
    public function getFeedTypes($continuation_token = null, $feed_scope = null, $limit = null, $marketplace_ids = null)
    {
        [$response] = $this->getFeedTypesWithHttpInfo($continuation_token, $feed_scope, $limit, $marketplace_ids);

        return $response;
    }

    /**
     * Operation getFeedTypesWithHttpInfo.
     *
     * @param string $continuation_token The server returns this token to the web client when the responses received require multiple pages to display. The web client sends this token back to the server to get the next page of results. (optional)
     * @param string $feed_scope         Specifies the frequency with which the feed file is made available (&lt;code&gt;HOURLY&lt;/code&gt;, &lt;code&gt;DAILY&lt;/code&gt;, &lt;code&gt;WEEKLY&lt;/code&gt;).&lt;br /&gt;&lt;br /&gt;Currently only &lt;code&gt;DAILY&lt;/code&gt; is supported. (optional)
     * @param string $limit              The number of records to show in the current response.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Default:&lt;/b&gt; 20&lt;br /&gt;&lt;b&gt;Minimum:&lt;/b&gt; 20&lt;br /&gt;&lt;b&gt;Maximum:&lt;/b&gt; 100 (optional)
     * @param string $marketplace_ids    Use this parameter to limit marketplaces you want to see. To search for multiple marketplaces at once, list them in the URI separated by commas.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;GET https://api.ebay.com/buy/feed/v1/feedtype?marketplaceids&#x3D;EBAY_FR,EBAY_AU&lt;/code&gt;.&lt;br /&gt;&lt;br /&gt;See &lt;a href&#x3D;\&quot;/api-docs/buy/feed/v1/overview.html#API\&quot;&gt;API Restrictions&lt;/a&gt; for information on supported sites. (optional)
     *
     * @throws \TNT\Ebay\Buy\Feed\V1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \TNT\Ebay\Buy\Feed\V1\Model\FeedTypeSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeedTypesWithHttpInfo($continuation_token = null, $feed_scope = null, $limit = null, $marketplace_ids = null)
    {
        $request = $this->getFeedTypesRequest($continuation_token, $feed_scope, $limit, $marketplace_ids);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), $e->getResponse() ? $e->getResponse()->getHeaders() : null, $e->getResponse() ? (string) $e->getResponse()->getBody() : null);
            } catch (ConnectException $e) {
                throw new ApiException("[{$e->getCode()}] {$e->getMessage()}", (int) $e->getCode(), null, null);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, (string) $request->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
            }

            switch ($statusCode) {
                case 200:
                    if ('\TNT\Ebay\Buy\Feed\V1\Model\FeedTypeSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\TNT\Ebay\Buy\Feed\V1\Model\FeedTypeSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\TNT\Ebay\Buy\Feed\V1\Model\FeedTypeSearchResponse';

            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TNT\Ebay\Buy\Feed\V1\Model\FeedTypeSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeedTypesAsync.
     *
     * @param string $continuation_token The server returns this token to the web client when the responses received require multiple pages to display. The web client sends this token back to the server to get the next page of results. (optional)
     * @param string $feed_scope         Specifies the frequency with which the feed file is made available (&lt;code&gt;HOURLY&lt;/code&gt;, &lt;code&gt;DAILY&lt;/code&gt;, &lt;code&gt;WEEKLY&lt;/code&gt;).&lt;br /&gt;&lt;br /&gt;Currently only &lt;code&gt;DAILY&lt;/code&gt; is supported. (optional)
     * @param string $limit              The number of records to show in the current response.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Default:&lt;/b&gt; 20&lt;br /&gt;&lt;b&gt;Minimum:&lt;/b&gt; 20&lt;br /&gt;&lt;b&gt;Maximum:&lt;/b&gt; 100 (optional)
     * @param string $marketplace_ids    Use this parameter to limit marketplaces you want to see. To search for multiple marketplaces at once, list them in the URI separated by commas.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;GET https://api.ebay.com/buy/feed/v1/feedtype?marketplaceids&#x3D;EBAY_FR,EBAY_AU&lt;/code&gt;.&lt;br /&gt;&lt;br /&gt;See &lt;a href&#x3D;\&quot;/api-docs/buy/feed/v1/overview.html#API\&quot;&gt;API Restrictions&lt;/a&gt; for information on supported sites. (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeedTypesAsync($continuation_token = null, $feed_scope = null, $limit = null, $marketplace_ids = null)
    {
        return $this->getFeedTypesAsyncWithHttpInfo($continuation_token, $feed_scope, $limit, $marketplace_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeedTypesAsyncWithHttpInfo.
     *
     * @param string $continuation_token The server returns this token to the web client when the responses received require multiple pages to display. The web client sends this token back to the server to get the next page of results. (optional)
     * @param string $feed_scope         Specifies the frequency with which the feed file is made available (&lt;code&gt;HOURLY&lt;/code&gt;, &lt;code&gt;DAILY&lt;/code&gt;, &lt;code&gt;WEEKLY&lt;/code&gt;).&lt;br /&gt;&lt;br /&gt;Currently only &lt;code&gt;DAILY&lt;/code&gt; is supported. (optional)
     * @param string $limit              The number of records to show in the current response.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Default:&lt;/b&gt; 20&lt;br /&gt;&lt;b&gt;Minimum:&lt;/b&gt; 20&lt;br /&gt;&lt;b&gt;Maximum:&lt;/b&gt; 100 (optional)
     * @param string $marketplace_ids    Use this parameter to limit marketplaces you want to see. To search for multiple marketplaces at once, list them in the URI separated by commas.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;GET https://api.ebay.com/buy/feed/v1/feedtype?marketplaceids&#x3D;EBAY_FR,EBAY_AU&lt;/code&gt;.&lt;br /&gt;&lt;br /&gt;See &lt;a href&#x3D;\&quot;/api-docs/buy/feed/v1/overview.html#API\&quot;&gt;API Restrictions&lt;/a&gt; for information on supported sites. (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeedTypesAsyncWithHttpInfo($continuation_token = null, $feed_scope = null, $limit = null, $marketplace_ids = null)
    {
        $returnType = '\TNT\Ebay\Buy\Feed\V1\Model\FeedTypeSearchResponse';
        $request = $this->getFeedTypesRequest($continuation_token, $feed_scope, $limit, $marketplace_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), (string) $response->getBody());
                }
            );
    }

    /**
     * Create request for operation 'getFeedTypes'.
     *
     * @param string $continuation_token The server returns this token to the web client when the responses received require multiple pages to display. The web client sends this token back to the server to get the next page of results. (optional)
     * @param string $feed_scope         Specifies the frequency with which the feed file is made available (&lt;code&gt;HOURLY&lt;/code&gt;, &lt;code&gt;DAILY&lt;/code&gt;, &lt;code&gt;WEEKLY&lt;/code&gt;).&lt;br /&gt;&lt;br /&gt;Currently only &lt;code&gt;DAILY&lt;/code&gt; is supported. (optional)
     * @param string $limit              The number of records to show in the current response.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Default:&lt;/b&gt; 20&lt;br /&gt;&lt;b&gt;Minimum:&lt;/b&gt; 20&lt;br /&gt;&lt;b&gt;Maximum:&lt;/b&gt; 100 (optional)
     * @param string $marketplace_ids    Use this parameter to limit marketplaces you want to see. To search for multiple marketplaces at once, list them in the URI separated by commas.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;GET https://api.ebay.com/buy/feed/v1/feedtype?marketplaceids&#x3D;EBAY_FR,EBAY_AU&lt;/code&gt;.&lt;br /&gt;&lt;br /&gt;See &lt;a href&#x3D;\&quot;/api-docs/buy/feed/v1/overview.html#API\&quot;&gt;API Restrictions&lt;/a&gt; for information on supported sites. (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFeedTypesRequest($continuation_token = null, $feed_scope = null, $limit = null, $marketplace_ids = null)
    {
        $resourcePath = '/feed_type';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $continuation_token,
            'continuation_token', // param base name
            'string', // openApiType
            'form', // style
            true // explode
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $feed_scope,
            'feed_scope', // param base name
            'string', // openApiType
            'form', // style
            true // explode
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'string', // openApiType
            'form', // style
            true // explode
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketplace_ids,
            'marketplace_ids', // param base name
            'string', // openApiType
            'form', // style
            true // explode
        ) ?? []);

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // For HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // For HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($queryParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (! empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option.
     *
     * @throws \RuntimeException on file opening failure
     *
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];

        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');

            if (! $options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: '.$this->config->getDebugFile());
            }
        }

        return $options;
    }
}
